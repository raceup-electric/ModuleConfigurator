#include "main.h" 
#include "raceup_fdcan.h"
#include "raceup_setup.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include <cstring>

// ------------------------------------------------------ Data Structures

/// @brief Structure to hold CAN message data in the FreeRTOS Queue
typedef struct {
  uint16_t id;
  uint8_t data[8];
  uint8_t len;
} CanRxMessage_t;

// ------------------------------------------------------ Function Prototypes

// Task Prototypes generated from config.yaml
{%- for task_name, task in os_config.tasks.items() %}
static void {{ task.entry }}(void *arg);
{%- endfor %}

// FDCAN Rx Callback Prototypes
{%- if modules.fdcan.enable %}
{%- for inst_name, inst in modules.fdcan.instances.items() if inst.enable %}
static void {{ inst_name | capitalize }}RxCallback(uint16_t id, uint8_t* data, uint8_t len);
{%- endfor %}
{%- endif %}

static void BlinkGPIO(GPIO_TypeDef* bank, uint16_t pin, uint32_t duration);

// ------------------------------------------------------ FreeRTOS Static Allocations

// Task Stacks and TCBs generated from config.yaml
{%- for task_name, task in os_config.tasks.items() %}
static StackType_t {{ task_name }}Stack[{{ task.stack_size }}];
static StaticTask_t {{ task_name }}Tcb;

{% endfor %}

// Rx Queue (Holds up to 10 incoming CAN messages)
#define RX_QUEUE_LENGTH 10
#define RX_QUEUE_ITEM_SIZE sizeof(CanRxMessage_t)
static uint8_t rxQueueStorage[RX_QUEUE_LENGTH * RX_QUEUE_ITEM_SIZE];
static StaticQueue_t rxQueueStruct;
static QueueHandle_t rxQueueHandle;

// ------------------------------------------------------ Application Entry
void app_start(void) {
  // 1. Create the FreeRTOS Queue for Rx messages
  rxQueueHandle = xQueueCreateStatic(RX_QUEUE_LENGTH, RX_QUEUE_ITEM_SIZE, rxQueueStorage, &rxQueueStruct);
  
  config_FDCAN();
  config_GPIO();

  // 3. Create Tasks dynamically
  {%- for task_name, task in os_config.tasks.items() %}
  xTaskCreateStatic({{ task.entry }}, "{{ task_name }}", {{ task.stack_size }}, NULL, {{ task.priority }}, {{ task_name }}Stack, &{{ task_name }}Tcb);
  {%- endfor %}
}

// ------------------------------------------------------ FDCAN Rx Callbacks (ISR Context)

{%- if modules.fdcan.enable %}
{%- for inst_name, inst in modules.fdcan.instances.items() if inst.enable %}
static void {{ inst_name | capitalize }}RxCallback(uint16_t id, uint8_t* data, uint8_t len) {
  // NOTE: This runs in the hardware interrupt context!
  
  CanRxMessage_t msg;
  msg.id = id;
  msg.len = len;
  std::memcpy(msg.data, data, len); // Copy data before leaving callback

  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  
  // Safely send data to the queue from an ISR
  xQueueSendFromISR(rxQueueHandle, &msg, &xHigherPriorityTaskWoken);

  // Yield if waking the Rx task requires a context switch
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
{%- endfor %}
{%- endif %}

// ------------------------------------------------------ Task Implementations

{%- for task_name, task in os_config.tasks.items() %}
static void {{ task.entry }}(void *arg) {
  {%- if 'rx' in task_name %}
  CanRxMessage_t received_msg;

  for (;;) {
    // Block indefinitely until a message arrives in the queue
    if (xQueueReceive(rxQueueHandle, &received_msg, portMAX_DELAY) == pdTRUE) {
      // Process the received message here safely in a task context!
      
      // Example: You can now safely check received_msg.id or received_msg.data
      // without stalling the FDCAN peripheral.
    }
  }
  {%- elif 'tx' in task_name %}
  uint8_t tx_data[8] = {0xDE, 0xAD, 0xBE, 0xEF, 0x11, 0x22, 0x33, 0x44};

  for (;;) {
    // Send a CAN frame every 1000ms
    RUP_FDCAN_Send(FDCAN1, 0x123, tx_data, 8);
    // BlinkGPIO(GPIOE, GPIO_PIN_3, 100); // Main LED
    vTaskDelay(pdMS_TO_TICKS(900));
  }
  {%- else %}
  // Default Task Loop
  for (;;) {
    BlinkGPIO(GPIOE, GPIO_PIN_3, 300); // Main LED
    vTaskDelay(pdMS_TO_TICKS(700));
  }
  {%- endif %}
}

{% endfor %}
static void BlinkGPIO(GPIO_TypeDef* bank, uint16_t pin, uint32_t duration) {
  // Turn the LED ON (Assumes active-high; swap SET/RESET if active-low)
  HAL_GPIO_WritePin(bank, pin, GPIO_PIN_SET);
  
  // Keep it on for the requested duration, yielding the CPU to other tasks
  vTaskDelay(pdMS_TO_TICKS(duration));
  
  // Turn the LED OFF
  HAL_GPIO_WritePin(bank, pin, GPIO_PIN_RESET);
}
